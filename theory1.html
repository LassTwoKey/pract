<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Принципы структурного и модульного программирования</title>
	<meta charset="UTF-8">
	<meta name="format-detection" content="telephone=no">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="img/icons/favicon.ico">
	<link rel="stylesheet" href="css/style.min.css?_v=20220205185520">
</head>

<body>
	<div class="wrapper">
		<header class="header">
	<div class="header__body">
		<div class="header__title-block">
			<div class="header__container container">
				<h1 class="header__title">Основы Программирования</h1>
			</div>
		</div>
		<nav class="header__menu menu">
			<div class="header__container container">
				<ul class="menu__list">
					<li class="menu__item"><a href="index.html" class="menu__link">Главная</a></li>
					<li class="menu__item"><a href="tests.html" class="menu__link">Тесты</a></li>
					<li class="menu__item"><a href="theory.html" class="menu__link">Теория</a></li>
					<li class="menu__item"><a href="pract.html" class="menu__link">Практические</a></li>
				</ul>
			</div>
		</nav>
	</div>
</header>
		<main class="page">
			<div class="page__wrapper wrapper-page theory1">
				<div class="theory1__container container not-sidebar">
					<div class="theory1__title title-dart">Принципы структурного и модульного программирования.</div>
					<div class="theory1__block">
						<div class="theory1__sub-title title">Основные принципы структурного программирования</div>
						<div class="theory1__item common-text">
							<p class="theory1__item-text">В конце 60-х начале 70-х гг. XX столетия вырабатывается дисциплина,
								которая получила название <span>структурного программирования</span>. Ее появление и развитие
								связаны с
								именами Э. В. Дейкстры, Х.Д.Милса, Д. Е. Кнута и других ученых. Структурное программирование до
								настоящего времени остается основой технологии программирования. Соблюдение его принципов
								позволяет программисту быстро научиться писать ясные, безошибочные, надежные программы.
							</p>
							<p class="theory1__item-text">
								В основе структурного программирования лежит теорема, которая была строго доказана в теории
								программирования. Суть ее в том, что алгоритм для решения любой логической задачи можно
								составить только из структур «следование, ветвление, цикл». Их называют базовыми
								алгоритмическими структурами. Из предыдущих разделов учебника вы уже знакомы с этими
								структурами.
							</p>
							<p class="theory1__item-text">
								<span>Следование</span> — это линейная последовательность действий:
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t1.webp" type="image/webp"><img src="img/theory/t1.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								Каждый блок может содержать в себе как простую команду, так и сложную структуру, но обязательно
								должен иметь один вход и один выход.
							</p>
							<p class="theory1__item-text">
								<span>Ветвление</span> — алгоритмическая альтернатива. Управление передается одному из двух
								блоков в
								зависимости от истинности или ложности условия. Затем происходит выход на общее продолжение:
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t2.webp" type="image/webp"><img src="img/theory/t2.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								Неполная форма ветвления имеет место, когда на ветви «нет» пусто:
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t3.webp" type="image/webp"><img src="img/theory/t3.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								<span>Цикл</span> — повторение некоторой группы действий по условию. Различаются два типа цикла.
								Первый —
								<span>цикл с предусловием</span> (цикл-пока):
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t4.webp" type="image/webp"><img src="img/theory/t4.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								Пока условие истинно, выполняется серия, образующая тело цикла. Второй тип циклической структуры
								— <span>цикл с постусловием</span> (цикл-до):
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t5.webp" type="image/webp"><img src="img/theory/t5.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								Здесь тело цикла предшествует условию цикла. Тело цикла повторяет свое выполнение, если условие
								ложно. Повторение кончается, когда условие станет истинным. Теоретически необходимым и
								достаточным является лишь первый тип цикла — цикл с предусловием. Любой циклический алгоритм
								можно построить с его помощью. Это более общий вариант цикла, чем цикл-до. В самом деле, тело
								цикла-до хотя бы один раз обязательно выполнится, так как проверка условия происходит после
								завершения его выполнения. А для цикла-пока возможен такой вариант, когда тело цикла не
								выполнится ни разу. Поэтому в любом языке программирования можно было бы ограничиться только
								циклом-пока
							</p>
							<p class="theory1__item-text">
								Однако в ряде случаев применение цикла-до оказывается более удобным, и поэтому он используется.
							</p>
							<p class="theory1__item-text">
								Иногда в литературе структурное программирование называют программированием без goto.
								Действительно, при таком подходе нет места безусловному переходу. Неоправданное использование в
								программах оператора goto лишает ее структурности, а значит, всех связанных с этим положительных
								свойств: прозрачности и надежности алгоритма. Хотя во всех процедурных языках программирования
								этот оператор присутствует, однако, придерживаясь структурного подхода, его употребления следует
								избегать.
							</p>
							<p class="theory1__item-text">
								Сложный алгоритм состоит из соединенных между собой базовых структур. Соединяться эти структуры
								могут двумя способами: последовательным и вложенным. Эта ситуация аналогична тому, что мы
								наблюдаем в электротехнике, где любая сколь угодно сложная электрическая цепь может быть
								разложена на последовательно и параллельно соединенные участки.
							</p>
							<p class="theory1__item-text">
								Вложенные алгоритмические структуры не являются аналогом параллельно соединенных проводников.
								Здесь больше подходит аналогия с матрешками, помещенными друг в друга. Если блок, составляющий
								тело цикла, сам является циклической структурой, то, значит, имеют место вложенные циклы. В свою
								очередь, внутренний цикл может иметь внутри себя еще один цикл и т.д. В связи с этим вводится
								представление о глубине вложенности циклов. Точно так же и ветвления могут быть вложенными друг
								в друга.
							</p>
							<p class="theory1__item-text">
								Структурный подход требует соблюдения стандарта в изображении блок-схем алгоритмов. Чертить их
								нужно так, как это делалось во всех приведенных примерах. Каждая базовая структура должна иметь
								один вход и один выход. Нестандартно изображенная блок-схема плохо читается, теряется
								наглядность алгоритма. Вот несколько примеров структурных блок-схем алгоритмов.
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t6.webp" type="image/webp"><img src="img/theory/t6.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								Такие блок-схемы легко читаются. Их структура хорошо воспринимается зрительно. Структуре каждого
								алгоритма можно дать название. У приведенных блок-схем следующие названия:
							</p>
							<p class="theory1__item-text">
								1. Вложенные ветвления. Глубина вложенности равна единице.
							</p>
							<p class="theory1__item-text">
								2. Цикл с вложенным ветвлением.
							</p>
							<p class="theory1__item-text">
								3. Вложенные циклы-пока. Глубина вложенности — единица.
							</p>
							<p class="theory1__item-text">
								4. Ветвление с вложенной последовательностью ветвлений на положительной ветви и с вложенным
								циклом-пока на отрицательной ветви.
							</p>
							<p class="theory1__item-text">
								5. Следование ветвления и цикла-до.
							</p>
							<p class="theory1__item-text">
								6. Вложенные циклы. Внешний — цикл-пока, внутренний — цикл-до.
							</p>
							<p class="theory1__item-text">
								Наряду с блок-схемами для описания алгоритмов часто используются псевдокоды. Учебный
								алгоритмический язык школьной информатики является примером такого псевдокода. Учебный АЯ —
								структурный псевдокод. В нем вообще отсутствует безусловный переход. Обучение составлению
								алгоритмов на этом языке способствует «структурному воспитанию» программиста.
							</p>
							<p class="theory1__item-text">
								Языки программирования Паскаль и Си называют языками структурного программирования. В них есть
								все необходимые управляющие конструкции для структурного построения программы. Наглядность
								такому построению придает структуризация внешнего вида текста программы. Основной используемый
								для этого прием — сдвиги строк, которые должны подчиняться следующим правилам:
							</p>
							<p class="theory1__item-text import-text">
								конструкции одного уровня вложенности записываются на одном вертикальном уровне (начинаются с
								одной позиции в строке);
							</p>
							<p class="theory1__item-text import-text">
								вложенная конструкция записывается смещенной по строке на несколько позиций вправо относительно
								внешней для нее конструкции.
							</p>
							<p class="theory1__item-text">
								Структурная методика алгоритмизации — это не только форма описания алгоритма, но это еще и
								способ мышления программиста. Создавая алгоритм, нужно стремиться составлять его из стандартных
								структур. Если использовать строительную аналогию, можно сказать, что структурная методика
								построения алгоритма подобна сборке здания из стандартных секций в отличие от складывания по
								кирпичику.
							</p>
							<p class="theory1__item-text">
								<span>Еще одним важнейшим технологическим приемом структурного программирования является
									декомпозиция
									решаемой задачи</span> на подзадачи более простые с точки зрения программирования части
								исходной
								задачи. Алгоритмы решения таких подзадач называются вспомогательными алгоритмами. В связи с этим
								возможны два пути в построении алгоритма:
							</p>
							<p class="theory1__item-text import-text">
								«сверху вниз»: сначала строится основной алгоритм, затем вспомогательные алгоритмы;
							</p>
							<p class="theory1__item-text import-text">
								«снизу вверх»: сначала составляются вспомогательные алгоритмы, затем основной.
							</p>
							<p class="theory1__item-text import-text">
								Первый подход еще называют <span>методом последовательной детализации</span>, второй -
								<span>сборочным методом</span>.
							</p>
							<p class="theory1__item-text">
								<span>Cборочный метод</span> предполагает накопление и использование библиотек вспомогательных
								алгоритмов,
								реализованных в языках программирования в виде подпрограмм, процедур, функций. При
								последовательной детализации сначала строится основной алгоритм, а затем в него вносятся
								обращения к вспомогательным алгоритмам первого уровня. После этого составляются вспомогательные
								алгоритмы первого уровня, в которых могут присутствовать обращения к вспомогательным алгоритмам
								второго уровня, и т.д. Вспомогательные алгоритмы самого нижнего уровня состоят только из простых
								команд.
							</p>
							<p class="theory1__item-text">
								<span>Метод последовательной детализации</span> применяется в любом конструировании сложных
								объектов. Это
								естественная логическая последовательность мышления конструктора: постепенное углубление в
								детали. В нашем случае речь идет тоже о конструировании, но только не технических устройств, а
								алгоритмов. Достаточно сложный алгоритм другим способом построить практически невозможно.
							</p>
							<p class="theory1__item-text">
								<span>Методика последовательной детализации позволяет организовать работу коллектива
									программистов над
									сложным проектом</span>. Например, руководитель группы строит основной алгоритм, а разработку
								вспомогательных алгоритмов и написание соответствующих подпрограмм поручает своим сотрудникам.
								Участники группы должны лишь договориться об интерфейсе (т. е. взаимосвязи) между
								разрабатываемыми программными модулями, а внутренняя организация программы личное дело
								программиста.
							</p>
						</div>
					</div>
					<div class="theory1__block">
						<div class="theory1__sub-title title">Методы последовательной детализации.</div>
						<div class="theory1__item common-text">
							<p class="theory1__item-text">
								<span>Суть метода заключается в следующем</span>: сначала анализируется исходная задача. В ней
								выделяются
								подзадачи. Строится иерархия таких подзадач.
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t7.webp" type="image/webp"><img src="img/theory/t7.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text item-text-center">
								Рис.1.8. Построение иерархии подзадач
							</p>
							<p class="theory1__item-text">
								<span>Затем составляются алгоритмы</span> (или программы), начиная с основного алгоритма
								(основной
								программы), далее вспомогательные алгоритмы (подпрограммы) с последовательным углублением
								уровня, пока не получим алгоритмы, состоящие из простых команд.
							</p>
							<p class="theory1__item-text">
								<span>Рассмотрим процесс создания алгоритма Домик для исполнителя Чертежник методом
									последовательной
									детализации</span>. Пусть необходимо нарисовать домик с крышей.
							</p>
							<p class="theory1__item-text">
								<span>Сначала запишем алгоритм, состоящий из крупных блоков</span>. Такими блоками, содержащими
								«непонятные»
								для исполнителя Чертежник команды, являются блоки стена, крыша. Теперь детализируем эти блоки и
								запишем их в виде вспомогательных алгоритмов, содержащих понятные Чертежнику команды.
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t8.webp" type="image/webp"><img src="img/theory/t8.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								В результате мы имеем основной алгоритм (домик), созданный методом последовательной детализации,
								в который входят как составные части два вспомогательных алгоритма (стена, крыша).
							</p>
							<p class="theory1__item-text">
								Рассмотрим задачу «Интерпретатор»: дана исходная символьная строка, имеющая следующий вид:
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t9.webp" type="image/webp"><img src="img/theory/t9.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								На месте а и b стоят десятичные цифры; значком
								<span class="img-text-wrapper"><picture><source srcset="img/theory/plus.webp" type="image/webp"><img src="img/theory/plus.jpg" alt=""></picture></span> обозначен
								один из знаков операций: +, -, *.
								Нужно, чтобы машина вычислила это выражение и после знака = вывела результат. Операция деления
								не рассматривается для того, чтобы иметь дело только с целыми числами.
							</p>
							<p class="theory1__item-text">
								Сформулируем требования к программе Interpretator.
							</p>
							<p class="theory1__item-text">
								1. Операнды а и b могут быть многозначными целыми положительными числами в пределах MaxInt.
							</p>
							<p class="theory1__item-text">
								2. Между элементами строки, а также в начале и в конце могут стоять пробелы.
							</p>
							<p class="theory1__item-text">
								3. Программа осуществляет синтаксический контроль текста. Ограничимся простейшим вариантом
								контроля: строка должна состоять только из цифр, знаков операций, знака = и пробелов.
							</p>
							<p class="theory1__item-text">
								4. Проводится семантический контроль: строка должна быть построена по схеме
								<span class="img-text-wrapper"><picture><source srcset="img/theory/t9.webp" type="image/webp"><img src="img/theory/t9.jpg" alt=""></picture></span> . Ошибка, если
								какой-то элемент отсутствует или нарушен их
								порядок.
							</p>
							<p class="theory1__item-text">
								5. Осуществляется контроль диапазона значений операндов и результата (не должны выходить за
								пределы MaxInt).
							</p>
							<p class="theory1__item-text">
								Уже из перечня требований становится ясно, что программа будет непростой. Составлять ее мы
								будем, используя метод последовательной детализации. Начнем с того, что представим в самом общем
								виде алгоритм как линейную последовательность этапов решения задачи:
							</p>
							<p class="theory1__item-text">
								1. Ввод строки.
							</p>
							<p class="theory1__item-text">
								2. Синтаксический контроль (нет ли недопустимых символов?).
							</p>
							<p class="theory1__item-text">
								3. Семантический контроль (правильно ли построено выражение?).
							</p>
							<p class="theory1__item-text">
								4. Выделение операндов. Проверка операндов на допустимый диапазон значений. Перевод в целые
								числа.
							</p>
							<p class="theory1__item-text">
								5. Выполнение операции. Проверка результата на допустимый диапазон.
							</p>
							<p class="theory1__item-text">
								6. Вывод результата.
							</p>
							<p class="theory1__item-text">
								Этапы 2, 3, 4, 5 будем рассматривать как подзадачи первого уровня, назвав их (и будущие
								подпрограммы) соответственно Sintax, Semantika, Operand, Calc
							</p>
							<p class="theory1__item-text">
								В свою очередь, для их реализации потребуется решение следующих подзадач: пропуск лишних
								пробелов (Propusk), преобразование символьной цифры в целое число (Cifra). Кроме того, при
								выделении операндов понадобится распознавать операнд, превышающий максимально допустимое
								значение (Error). Обобщая все сказанное в схематической форме, получаем некоторую структуру
								подзадач. Этой структуре будет соответствовать аналогичная структура программных модулей.
							</p>
							<div class="theory1__item-image">
								<picture><source srcset="img/theory/t10.webp" type="image/webp"><img src="img/theory/t10.jpg" alt=""></picture>
							</div>
							<p class="theory1__item-text">
								<span>Первый шаг детализации.</span>
							</p>
							<p class="theory1__item-text">
								Сначала намечают все необходимые подпрограммы, указав лишь их заголовки (спецификации). На месте
								тела подпрограмм записывают поясняющие комментарии (такой вид подпрограммы называется
								«заглушкой»). Затем составляют основную часть программы.
							</p>
							<p class="theory1__item-text">
								<span>Второй шаг детализации.</span>
							</p>
							<p class="theory1__item-text">
								Детальная разработка подпрограмм - Sintax, Semantika, Operand, Calc.
							</p>
							<p class="theory1__item-text item-text-center">
								<span>Достоинства метода последовательной детализации:</span>
							</p>
							<p class="theory1__item-text">
								1. Сохраняется концептуальная целостность программы: от сложного к простому.
							</p>
							<p class="theory1__item-text">
								2. Проектирование программы, кодирование, проверку и документирование можно делать параллельно.
							</p>
							<p class="theory1__item-text">
								3. В каждый момент времени (даже в начале разработки) имеется работающий вариант программы.
							</p>
							<p class="theory1__item-text">
								4. Фразы естественного языка, будучи закомментированными, служат хорошим путеводителем по
								программе.
							</p>
							<p class="theory1__item-text item-text-center">
								<span>Недостатки метода последовательной детализации:</span>
							</p>
							<p class="theory1__item-text">
								Однако, данный метод имеет и ряд недостатков. Так, при программировании "снизу вверх" уже
								реализованные, отлаженные и протестированные модули иногда приходится отбрасывать, если в
								вызывающих частях программы обнаружились неустранимые ошибки, и необходимо переделывать целый
								блок.
							</p>
							<p class="theory1__item-text">
								При программировании "снизу вверх если оказывается, что модуль низкого уровня невозможно
								реализовать, как задумывалось, иногда приходится переделывать весь проект; при отладке
								поглощается больше машинных ресурсов.
							</p>
							<p class="theory1__item-text">
								Реализация методов последовательной детализации на языках программирования связано с понятием
								процедур и функций. С технологиями проектирования функций на языке C/C++ можно ознакомиться в
								разделе <a href="" class="theory1__item-text-link">Функции.</a>
							</p>
							<p class="theory1__item-text">
								<a href="" class="theory1__item-text-link">Пример реализации метода пошаговой детализации на
									языке С.</a>
							</p>
						</div>
					</div>
				</div>
			</div>
		</main>
		<footer class="footer">
	<div class="footer__container container">
		<a href="index.html" class="footer__link">Ссылка на Главную</a>
	</div>
</footer>

<div class="wrapper__alert-ie alert-ie">
	<div class="alert-ie__message">
		<div class="alert-ie__text"><span>Internet Explorer</span> устарел, Запустить с другого браузера</div>
	</div>
</div>
	</div>
	
	<script src="js/app.min.js?_v=20220205185520"></script>
</body>

</html>